# Памятка по современному JavaScript
![Памятка по современному JavaScript](https://i.imgur.com/aexPxMb.png)
<small>За картинку спасибо [Ahmad Awais ⚡️](https://github.com/ahmadawais)</small>

## Введение

### Мотивация
В этом документе собраны возможности языка JavaScript, с которыми вы наверняка столкнетесь в современных проектах и примерах кода.

Цель этого руководства — не обучить вас JavaScript с нуля, а помочь разработчикам с базовыми знаниями, которые при изучении современных кодовых баз (или, скажем, React) сталкиваются со сложностями из-за использованных в них концепций JavaScript.

Иногда я буду давать личные советы, которые могут быть спорными, но постараюсь упоминать, что это личное мнение.
> **Примечание:** Большинство представленных здесь понятий взяты из обновления языка JavaScript (ES2015, который часто называют ES6). Вы можете найти новые функции из этого обновления [здесь](http://es6-features.org); они хорошо описаны.

### Дополнительные ресурсы
Если вам сложно разобраться с каким-то понятием, рекомендую искать ответы на вопросы на следующих ресурсах:
- [MDN (сеть разработчиков Mozilla)](https://developer.mozilla.org/ru/search?q=).
- [Вы не знаете JS (серия книг)](https://github.com/azat-io/you-dont-know-js-ru).
- [ES6 Features with examples](http://es6-features.org).
- [Блог WesBos (ES6)](http://wesbos.com/category/es6/).
- [Javascript Basics for Beginners](https://www.udacity.com/course/javascript-basics--ud804) — бесплатный курс от Udacity.
- [Reddit (JavaScript)](https://www.reddit.com/r/javascript/).
- [Google](https://www.google.com/) для поиска специализированных блогов и ресурсов.
- [StackOverflow](https://stackoverflow.com/questions/tagged/javascript).

## Содержание
- [Памятка по современному JavaScript](#Памятка-по-современному-javascript)
  * [Введение](#Введение)
    + [Мотивация](#Мотивация)
    + [Дополнительные ресурсы](#Дополнительные-ресурсы)
  * [Содержание](#Содержание)
  * [Понятия](#Понятия)
    + [Объявление переменных: `var`, `const`, `let`](#Объявление-переменных-var-const-let)
      - [Краткое объяснение](#Краткое-объяснение)
      - [Пример кода](#Пример-кода)
      - [Подробное объяснение](#Подробное-объяснение)
      - [Дополнительные материалы](#Дополнительные-материалы)
    + [Стрелочные функции](#-Стрелочные-функции)
      - [Пример кода](#Пример-кода-1)
      - [Подробное объяснение](#Подробное-объяснение-1)
        * [Краткость](#Краткость)
        * [Обращение к `this`](#Обращение-к-this)
      - [Полезные ресурсы](#Полезные-ресурсы)
    + [Значение аргументов функции по умолчанию](#Значение-аргументов-функции-по-умолчанию)
      - [Дополнительные материалы](#Дополнительные-материалы-1)
    + [Деструктуризация объектов и массивов](#Деструктуризация-объектов-и-массивов)
      - [Объяснение с помощью примера кода](#Объяснение-с-помощью-примера-кода)
      - [Полезные ресурсы](#Полезные-ресурсы-1)
    + [Методы массивов - `map` / `filter` / `reduce`](#Методы-массивов--map--filter--reducee)
      - [Пример кода](#Пример-кода-2)
      - [Объяснение](#Объяснение)
        * [`Array.prototype.map()`](#arrayprototypemap)
        * [`Array.prototype.filter()`](#arrayprototypefilter)
        * [`Array.prototype.reduce()`](#arrayprototypereduce)
      - [Дополнительные материалы](#Дополнительные-материалы-2)
    + [Оператор расширения `...`](#Оператор-расширения-)
      - [Пример кода](#Пример-кода-3)
      - [Объяснение](#Объяснение-1)
        * [В итерируемых объектах (наподобие массивов)](#В-итерируемых-объектах-наподобие-массивов)
        * [Оставшиеся аргументы функции](#Оставшиеся-аргументы-функции)
        * [Расширение свойств объектов](#Расширение-свойств-объектов)
      - [Дополнительные материалы](#Дополнительные-материалы-3)
    + [Сокращенная запись свойств объектов](#Сокращенная-запись-свойств-объектов)
      - [Объяснение](#Объяснение-2)
      - [Дополнительные материалы](#Дополнительные-материалы-4)
    + [Промисы](#Промисы)
      - [Пример кода](#Пример-кода-4)
      - [Пояснение](#Пояснение)
        * [Создание промиса](#Создание-промиса)
        * [Использование обработчиков промисов](#Использование-обработчиков-промисов)
      - [Дополнительные материалы](#Дополнительные-материалы-5)
    + [Шаблонные строки](#Шаблонные-строки)
      - [Пример кода](#Пример-кода-5)
      - [Дополнительные материалы](#Дополнительные-материалы-6)
    + [Шаблонные строки с тегами](#Шаблонные-строки-с-тегами)
      - [Дополнительные материалы](#Дополнительные-материалы-7)
    + [Импорт / экспорт](#Импорт--экспорт)
      - [Объяснение-с-помощью-примера-кода](#Объяснение-с-примером-кода-1)
        * [Именованный экспорт](#Именованный-экспорт)
        * [Импорт / экспорт по умолчанию](#Импорт--экспорт-по-умолчанию)
      - [Дополнительные материалы](#Дополнительные-материалы-8)
    + [`this` в JavaScript](#-this-в-javascript)
      - [Дополнительные материалы](#Дополнительные-материалы-9)
    + [Класс](#Класс)
      - [Примеры](#Примеры)
      - [Дополнительные материалы](#Дополнительные-материалы-10)
    + [Async Await](#async-await)
      - [Пример кода](#Пример-кода-6)
      - [Объяснение с помощью примера кода](#Объяснение-с-помощью-примера-кода-2)
      - [Обработка ошибок](#Обработка-ошибок)
      - [Дополнительные материалы](#Дополнительные-материалы-11)
    + [Правдиво / Ложно](#Правдиво--Ложно)
    + [Статические методы](#Статические-методы)
      - [Краткое объяснение](#Краткое-объяснение-1)
      - [Пример кода](#Пример-кода-7)
      - [Подробное объяснение](#Подробное-объяснение-2)
        * [Вызов статических методов из статического метода](#Вызов-статических-методов-из-статического-метода)
        * [Вызов статических методов из нестатических методов](#Вызов-статических-методов-из-нестатических-методов)
      - [Дополнительные материалы](#Дополнительные-материалы-12)
  * [Глоссарий](#Глоссарий)
    + [Область видимости](#-Область-видимости)
    + [Изменение переменных](#-Изменение-переменных)

## Понятия

### Объявление переменных: `var`, `const`, `let`
В JavaScript есть три ключевых слова, отвечающих за объявление переменных, и у каждого из них свои особенности. Эти слова − `var`, `let` и `const`.

#### Краткое объяснение
Переменным, объявленным с помощью ключевого слова `const`, нельзя позднее присвоить новое значение, в то время как переменным, объявленным с помощью `let` или `var`, можно.
Я рекомендую всегда объявлять переменные ключевым словом `const`, а `let` использовать только в том случае, если позже эту переменную понадобится *изменить* или переопределить.
<table>
<tr>
<th></th>
<th>Область видимости</th>
<th>Можно переопределять</th>
<th>Можно изменять</th>
<th><a href="#tdz_sample">Временная мертвая зона</a></th>
</tr>
<tr>
<th>`const`</th>
<td>Блок</td>
<td>Нет</td>
<td><a href="#const_mutable_sample">Да</a></td>
<td>Да</td>
</tr>
<tr>
<th>`let`</th>
<td>Блок</td>
<td>Да</td>
<td>Да</td>
<td>Да</td>
</tr>
<tr>
<th>`var`</th>
<td>Функция</td>
<td>Да</td>
<td>Да</td>
<td>Нет</td>
</tr>
</table>

#### Пример кода
```js
const person = "Коля";
person = "Ваня" // Вызовет ошибку, переменной person нельзя присвоить новое значение.
```
```js
let person = "Коля";
person = "Ваня";
console.log(person) // -> "Ваня", присвоение нового значения разрешено в случае с let.
```

#### Подробное объяснение
[*Область видимости*](#scope_def) переменной определяет, где эта переменная доступна в коде.

##### `var`
Областью видимости переменных, объявленных с помощью `var`, является функция. Это означает, что если переменная была создана внутри функции, то у всего внутри этой функции есть доступ к этой переменной. Кроме того, переменная с областью видимости внутри функции недоступна за пределами этой функции.

Можно думать об этом вот так: если у переменной область видимости *Х*, то эта переменная — как бы свойство Х.
```js
function myFunction() {
  var myVar = "Коля";
  console.log(myVar); // -> "Коля" — к myVar есть доступ изнутри функции.
}
console.log(myVar); // undefined, извне доступа к myVar нет.
```
Вот менее очевидный пример области видимости переменных:
```js
function myFunction() {
  var myVar = "Коля";
  if (true) {
      var myVar = "Ваня";
      console.log(myVar); // -> "Ваня"
      /* действительно, myVar имеет область видимости внутри функции,
      мы всего лишь удалили предыдущее значение переменной myVar "Коля"
      и заменили его на "Ваня". */
    }
    console.log(myVar); // -> "Ваня" — обратите внимание, как код в блоке if повлиял на это значение.
  }
  console.log(myVar); // -> undefined, переменная myVar недоступна за пределами функции, в которой определена.
```
Кроме этого, переменные, объявленные ключевым словом `var`, при исполнении кода перемещаются в начало области видимости. Это называется [поднятие переменных](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/var#Поднятие_переменных).
Этот фрагмент кода:
```js
console.log(myVar) // -> undefined — ошибок нет.
var myVar = 2;
```
при исполнении понимается как:
```js
var myVar;
console.log(myVar) // -> undefined — ошибок нет.
myVar = 2;
```

##### `let`
`var` и `let` очень похожи друг на друга, но переменные, объявленные словом `let`:
- имеют в качестве области видимости блок;
- **недоступны** до объявления;
- не могут быть повторно объявлены в той же области видимости.

Давайте разберем, насколько важна блочная область видимости, на том же самом примере:
```js
function myFunction() {
  let myVar = "Коля";
  if (true) {
    let myVar = "Ваня";
    console.log(myVar); // -> "Ваня"
    /* Поскольку myVar имеет блочную область видимости, здесь мы только что создали новую переменную myVar.
    Эта переменная недоступна вне блока и никаким образом не зависит
    от первой переменной myVar, которую мы создали до этого! */
  }
  console.log(myVar); // -> "Коля" — обратите внимание: инструкции в блоке if НЕ повлияли на значение переменной.
}
console.log(myVar); // -> undefined, доступа к myVar извне функции нет.
```
<a name="tdz_sample"></a> Теперь посмотрим, что значит «переменные, объявленные словами `let` и `const`, недоступны до их объявления»:
```js
console.log(myVar) // вызовет ReferenceError!
let myVar = 2;
```
В отличие от переменных, объявленных с помощью `var`, если вы попытаетесь прочитать или записать переменную, объявленную с помощью `let` или `const`, до того, как она будет объявлена, произойдёт ошибка. Этот феномен часто называют  [*Временной мёртвой зоной*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let).  
> **Примечание:** строго говоря, объявления переменных с использованием `let` и `const` тоже поднимаются, однако их инициализация — нет. Они сделаны так, что использовать их до объявления нельзя. Поэтому интуитивно ощущается так, будто эти переменные не поднимаются, но это не так. Ищите больше информации в [этом очень подробном объяснении](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified), если хотите знать больше.

В дополнение к сказанному, вы не можете переобъявить переменную, объявленную с помощью `let`:
```js
let myVar = 2;
let myVar = 3; // Вызовет SyntaxError.
```

##### `const`
Переменные, объявленные ключевым словом `const`, ведут себя так же, как переменные, объявленные ключевым словом `let`, только их еще и нельзя переопределять.

Подводя итог, переменные, объявленные с помощью `const`:
- имеют в качестве области видимости блок;
- недоступны до объявления;
- не могут быть повторно объявлены в той же области видимости;
- не могут быть переопределены.
```js
const myVar = "Коля";
myVar = "Ваня" // вызовет ошибку, переопределять переменную нельзя.
```
```js
const myVar = "Коля";
const myVar = "Ваня" // вызовет ошибку, объявить переменную можно только один раз.
```
<a name="const_mutable_sample"></a> Но есть одна тонкость: переменные, объявленные с помощью `const`, не являются [**неизменными**](#mutation_def)! Конкретно это означает, что *объекты* и *массивы*, объявленные с помощью `const`, **могут** быть изменены.

В случае объектов:
```js
const person = {
  name: 'Коля',
};
person.name = 'Ваня'; // сработает! Переменная person не полностью переопределяется, а просто меняется.
console.log(person.name); // -> "Ваня"
person = "Сандра"; // вызовет ошибку, потому что переменные, объявленные словом const, переопределять нельзя.
```
В случае массивов:
```js
const person = [];
person.push('Ваня'); // сработает!  Переменная person не полностью переопределяется, а просто меняется.
console.log(person[0]); // -> "Ваня"
person = ["Коля"]; // вызовет ошибку, потому что переменные, объявленные словом const, переопределять нельзя
```

#### Дополнительные материалы
- [How let and const are scoped in JavaScript — WesBos](http://wesbos.com/javascript-scoping/)
- [Temporal dead zone (tdz) demystified](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified)

### <a name="arrow_func_concept"></a> Стрелочные функции
В обновлении ES6 JavaScript добавлены *стрелочные функции*, которые являются еще одним способом объявления и использования функций. Вот некоторые их преимущества:
- краткость;
- `this` берется из окружающего контекста;
- неявный возврат.

#### Пример кода
- Краткость и неявный возврат.
```js
function double(x) { return x * 2; } // Обычный способ.
console.log(double(2)); // -> 4
```
```js
const double = x => x * 2; // Та же функция, записанная в виде стрелочной функции с неявным возвратом.
console.log(double(2)); // -> 4
```
- Обращение к `this`.

Внутри стрелочной функции значение `this` равно значению `this` во внешней области видимости. В принципе, со стрелочными функциями вам больше не нужно делать трюк `that = this` перед вызовом функции внутри функции.
```js
function myFunc() {
  this.myVar = 0;
  setTimeout(() => {
    this.myVar++;
    console.log(this.myVar); // -> 1
  }, 0);
}
```

#### Подробное объяснение

##### Краткость
Стрелочные функции по ряду причин короче, чем традиционные. Рассмотрим все возможные случаи:
- Явный и неявный возврат.

**Явный возврат** — это функция, в теле которой используется ключевое слово `return`.
```js
function double(x) {
  return x * 2; // эта функция явно возвращает x * 2, использовано ключевое слово *return*.
}
```
При традиционном способе написания функций возврат всегда был явным. Со стрелочными функциями его можно сделать *неявным*. Это значит, что для возврата значения не нужно писать ключевое слово `return`.

Чтобы возврат значения был неявным, код функции должен быть написан в виде однострочного выражения.
```js
const double = (x) => {
  return x * 2; // Явный возврат.
}
```
Поскольку здесь нет ничего, кроме возвращаемого значения, возврат можно сделать неявным.
```js
const double = (x) => x * 2;
```
Для этого нам просто нужно **убрать фигурные скобки** и ключевое слово `return`. Поэтому это и называется *неявным* возвратом: ключевого слова `return` нет, но функция все равно вернет `x * 2`.
> **Примечание**: Если ваша функция не возвращает никаких значений (с *побочными эффектами*), то в ней нет ни явного, ни неявного возврата.

Кроме того, если вы хотите неявно возвращать *объект*, вы **должны поставить круглые скобки вокруг него**, так как иначе он будет конфликтовать с фигурными скобками блоков:
```js
const getPerson = () => ({ name: "Коля", age: 24 })
console.log(getPerson())
// { name: "Коля", age: 24 } — объект, неявно возвращенный стрелочной функцией.
```

- Только один аргумент.

Если ваша функция принимает только один аргумент, вы можете опустить скобки вокруг него. Если мы вернемся к функции `double` в коде выше:  
```js
const double = (x) => x * 2; // эта стрелочная функция принимает только один аргумент.
```
Скобки вокруг этого аргумента могут быть опущены:
```js
const double = x => x * 2; // эта стрелочная функция принимает только один параметр.
```
- Без аргументов.

Когда стрелочная функция вообще не принимает никаких аргументов, нужно написать пустые круглые скобки, иначе синтаксис будет неверным.
```js
() => { // Скобки есть, все хорошо.
  const x = 2;
  return x;
}
```
```js
=> { // Скобок нет, так работать не будет!
  const x = 2;
  return x;
}
```

##### Обращение к `this`
Чтобы понять эту тонкость, представленную стрелочными функциями, вы должны понимать, как [`this`](#this_def) ведёт себя в JavaScript.

В стрелочной функции значение `this` равно значению `this` внешнего окружения. Это означает, что стрелочная функция не создает новый `this`, а получает его из окружения.

Если вы не используете стрелочные функции и хотите получить доступ к переменной из `this` в функции внутри другой функции, вам придется использовать фокус с `that = this` или `self = this`.

Вот, к примеру, использование функции `setTimeout` внутри функции `myFunc`:
```js
function myFunc() {
  this.myVar = 0;
  var that = this; // Тот самый фокус *that = this*
  setTimeout(
    function() { // В этой области видимости функции создается новый *this*.
      that.myVar++;
      console.log(that.myVar); // -> 1
      console.log(this.myVar); // -> undefined — см. объявление функции выше.
    },
    0
  );
}
```
Но в случае стрелочных функций `this` берется из окружения:
```js
function myFunc() {
  this.myVar = 0;
  setTimeout(
    () => { // this берется из окружения. В данном случае — из myFunc
      this.myVar++;
      console.log(this.myVar); // -> 1
    },
    0
  );
}
```

#### Полезные ресурсы
- [JavaScript Arrow Functions Introduction — WesBos](http://wesbos.com/arrow-functions/).
- [Стрелочные функции в JavaScript — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions).
- [Javascript ES6 — Arrow Functions and Lexical `this`](https://hackernoon.com/javascript-es6-arrow-functions-and-lexical-this-f2a3e2a5e8c4).

### Значение аргументов функции по умолчанию
Начиная с обновления JavaScript ES2015, аргументам функции можно присваивать значения по умолчанию, используя следующий синтаксис:
```js
function myFunc(x = 10) {
  return x;
}
console.log(myFunc()); /* -> 10 — никакое значение не передается,
так что в myFunc х присваивается значение по умолчанию, т.е. 10 */
console.log(myFunc(5)); /* -> 5 — передается значение,
так что в myFunc х присваивается значение 5 */
console.log(myFunc(undefined)); /* -> 10 — передается значение undefined,
так что х присваивается значение по умолчанию */
console.log(myFunc(null)); // -> null — передается значение null. Подробнее см. ниже
```
Значения по умолчанию применяются только в двух случаях:
- не передано значение;
- передано значение `undefined`.

Другими словами, если передать в функцию параметр `null`, то параметр по умолчанию **не применится**.
> **Примечание:**: Присваивать значение по умолчанию можно в том числе и при работе с деструктурированными параметрами (см. пример в следующем понятии).

#### Дополнительные материалы
- [Extended Parameter Handling](http://es6-features.org/#DefaultParameterValues).
- [Параметры по умолчанию — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters).

### Деструктуризация объектов и массивов
**Деструктуризация** — это удобный способ создавать новые переменные, напрямую получая значения из объектов или массивов.

На практике *деструктуризацию* можно использовать, чтобы присваивать переменные, разбивая на части параметры функции или `this.props` в React-проектах.

#### Объяснение с примером кода
- Объект.

Давайте использовать во всех примерах следующий объект:
```js
const person = {
  firstName: "Коля",
  lastName: "Андреев",
  age: 35,
  sex: "М",
};
```
Без деструктуризации:
```js
const first = person.firstName;
const age = person.age;
const city = person.city || "Санкт-Петербург";
```
С деструктуризацией всё поместится в одну строчку:
```js
const { firstName: first, age, city = "Санкт-Петербург" } = person; // И всё!
console.log(age); /* -> 35 — Создана новая переменная age
и ей присвоено значение, равное person.age */
console.log(first); /* -> "Коля" — Создана новая переменная first
и ей присвоено значение, равное person.firstName */
console.log(firstName); /* -> undefined — person.firstName существует,
НО новая созданная переменная называется first */
console.log(city); /* -> "Санкт-Петербург" — Создана новая переменная city
и, поскольку свойство person.city ранее не было определено,
переменной присвоено альтернативное значение "Санкт-Петербург". */
```
> **Примечание:** В `const { age } = person;` скобки после ключевого слова `const` не используются для определения объекта или блока. Это синтаксис самой *деструктуризации*.

- Параметры функции.

Деструктуризация часто используется, чтобы разбить на части параметры в функциях.

Без деструктуризации:
```js
function joinFirstLastName(person) {
  const firstName = person.firstName;
  const lastName = person.lastName;
  return `${firstName}—${lastName}`;
}
joinFirstLastName(person); // -> "Коля-Андреев"
```
Если деструктурировать параметр `person`, то функция выйдет куда короче:
```js
function joinFirstLastName({ firstName, lastName }) { /* мы создали переменные firstName и lastName
  из частей параметра person */
  return `${firstName}—${lastName}`;
}
joinFirstLastName(person); // -> "Коля-Андреев"
```
Ещё удобнее использовать деструктуризацию со [стрелочными функциями](#arrow_func_concept):
```js
const joinFirstLastName = ({ firstName, lastName }) => `${firstName}—${lastName}`;
joinFirstLastName(person); // -> "Коля-Андреев"
```
- Массив.

Давайте рассмотрим следующий массив:
```js
const myArray = ["a", "b", "c"];
```
Без деструктуризации:
```js
const x = myArray[0];
const y = myArray[1];
```
С использованием деструктуризации:
```js
const [x, y] = myArray; // И это всё!
console.log(x); // -> "a"
console.log(y); // -> "b"
```

#### Полезные ресурсы
- [Destructuring Assignment](http://es6-features.org/#ArrayMatching).
- [Destructuring Assignment - WesBos](http://wesbos.com/destructuring-objects/).
- [ExploringJS — Destructuring](http://exploringjs.com/es6/ch_destructuring.html).

### Методы массивов — `map` / `filter` / `reduce`
`map`, `filter` и `reduce` — это методы массивов, пришедшие из парадигмы  [*функционального программирования*](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0).
Перечислю их:
- `Array.prototype.map()` берёт массив, делает что-то с его элементами. Возвращает массив трансформированных элементов.
- `Array.prototype.filter()` берёт массив, просматривает каждый элемент и решает, убрать его или оставить. Возвращает массив оставшихся значений.
- `Array.prototype.reduce()` берёт массив и вычисляет на основе элементов какое-то единое значение, которое и возвращает.

Я рекомендую пользоваться ими как можно чаще, следуя принципам функционального программирования, потому что они лаконичные, элегантные и их можно комбинировать.

Вооружившись этими тремя методами, вы можете обойтись без использования `for` и `forEach` в большинстве ситуаций. Когда в следующий раз соберётесь запустить цикл `for`, попробуйте решить задачу с помощью `map`, `filter` и `reduce`. Поначалу это будет трудно, потому что вам придётся научиться мыслить по-другому, но, разобравшись один раз, вы сможете применять эти методы без особых усилий.

#### Пример кода
```js
const numbers = [0, 1, 2, 3, 4, 5, 6];
const doubledNumbers = numbers.map(n => n * 2); // -> [0, 2, 4, 6, 8, 10, 12]
const evenNumbers = numbers.filter(n => n % 2 === 0); // -> [0, 2, 4, 6]
const sum = numbers.reduce((prev, next) => prev + next, 0); // -> 21
```
Давайте посчитаем сумму баллов всех студентов, которые набрали больше 10 баллов, используя `map`, `filter` и `reduce`:
```js
const students = [
  { name: "Коля", grade: 10 },
  { name: "Ваня", grade: 15 },
  { name: "Юля", grade: 19 },
  { name: "Наташа", grade: 9 },
];
const aboveTenSum = students
  .map(student => student.grade) // создаём массив оценок из массива студентов с помощью метода map
  .filter(grade => grade >= 10) // выбираем только оценки выше 10 при помощи метода filter
  .reduce((prev, next) => prev + next, 0); // суммируем все оценки выше 10 друг с другом
console.log(aboveTenSum); /* -> 44: 10 (Коля) + 15 (Ваня) + 19 (Юля),
оценка Наташи меньше 10 и была проигнорирована */
```

#### Объяснение
Давайте использовать в качестве примера следующий массив:
```js
const numbers = [0, 1, 2, 3, 4, 5, 6];
```

##### `Array.prototype.map()`
```js
const doubledNumbers = numbers.map(function(n) {
  return n * 2;
});
console.log(doubledNumbers); // -> [0, 2, 4, 6, 8, 10, 12]
```
Что же здесь происходит? Мы применяем к массиву `numbers` метод `map`, который взаимодействует с каждым элементом массива и передаёт его в нашу функцию. Цель функции — произвести расчёт и вернуть новое значение, чтобы `map` мог подставить его вместо переданного в функцию.

Давайте даже вынесем функцию из массива, чтобы было понятнее, что происходит:
```js
const doubleN = function(n) { return n * 2; };
const doubledNumbers = numbers.map(doubleN);
console.log(doubledNumbers); // -> [0, 2, 4, 6, 8, 10, 12]
```
`numbers.map(doubleN)` создаёт `[doubleN(0), doubleN(1), doubleN(2), doubleN(3), doubleN(4), doubleN(5), doubleN(6)]` что равняется `[0, 2, 4, 6, 8, 10, 12]`.
> **Примечание:** Если вы не хотите возвращать новый массив и просто хотите перебрать массив, совершая некоторые действия, то, возможно, вы захотите использовать просто `for` / `forEach` вместо метода `map`.

##### `Array.prototype.filter()`
```js
const evenNumbers = numbers.filter(function(n) {
  return n % 2 === 0; // истинно, если n чётное, ложно, если n нечетное
});
console.log(evenNumbers); // -> [0, 2, 4, 6]
```
Мы применяем `filter` к массиву `numbers`. `filter` взаимодействует с каждым элементом массива и передаёт его в нашу функцию. Функция возвращает булево значение, что определяет, будет ли элемент сохранён в массиве. Затем `filter` возвращает массив отфильтрованных значений.

##### `Array.prototype.reduce()`
Цель метода `reduce` заключается в том, чтобы вычислить на основе массива какое-то одно значение. Какие именно вычисления метод произведет с элементами, зависит только от вас.
```js
const sum = numbers.reduce(
  function(acc, n) {
    return acc + n;
  },
0 // значение аккумулирующей переменной на первом шаге цикла.
);
console.log(sum); // -> 21
```
Так же, как методы `.map` и `.filter`, метод `.reduce` применяется к массиву и в качестве первого параметра принимает функцию.

На этот раз, впрочем, кое-что изменилось:
- `.reduce` принимает два параметра.

Первый параметр это функция, которая будет вызываться на каждом шаге цикла.

Второй параметр это значение аккумулирующей переменной (`acc` в нашем случае) на первом шаге цикла (чтобы разобраться, читайте далее).
- Параметры функции.

Функция, которую вы передаёте в качестве первого параметра метода `.reduce`, принимает два параметра. Первый параметр — это аккумулирующая переменная (`acc` в нашем примере), второй параметр — текущий элемент.

Аккумулирующая переменная равна значению, возвращённому нашей функцией на **предыдущем** шаге цикла. В самом начале каждого цикла `acc` равна значению, которое вы передали в качестве второго параметра `.reduce`.

###### На первом шаге
`acc = 0` потому что мы передали `0` в качестве второго параметра метода `reduce`.

`n = 0` это первый элемент массива `number`.

Функция возвращает `acc` + `n` --> 0 + 0 --> 0.

###### На втором шаге
`acc = 0` потому что это значение функция вернула на предыдущем шаге.

`n = 1` это второй элемент массива `number`.

Функция возвращает `acc` + `n` --> 0 + 1 --> 1.

###### На третьем шаге
`acc = 1` потому что это значение функция вернула на предыдущем шаге.

`n = 2` это третий элемент массива `number`.

Функция возвращает `acc` + `n` --> 1 + 2 --> 3.

###### На четвертом шаге
`acc = 3` потому что это значение функция вернула на предыдущем шаге.

`n = 3` это четвёртый элемент массива `number`.

Функция возвращает `acc` + `n` --> 3 + 3 --> 6.

###### На последнем шаге
`acc = 15` потому что это значение функция вернула на предыдущем шаге.

`n = 6` последний элемент массива `number`.

Функция возвращает `acc` + `n` --> 15 + 6 --> 21.

Поскольку это был последний шаг, `.reduce` возвращает `21`.

#### Дополнительные материалы
- [Understanding map, filter and reduce in JavaScript](https://hackernoon.com/understanding-map-filter-and-reduce-in-javascript-5df1c7eee464).

### Оператор расширения `...`
Оператор расширения `...`, появившийся в ES2015, предназначен для раскрытия итерируемых объектов (например, массивов) в тех местах, где можно поместить несколько элементов.

#### Пример кода
```js
const arr1 = ["a", "b", "c"];
const arr2 = [...arr1, "d", "e", "f"]; // -> ["a", "b", "c", "d", "e", "f"]
```
```js
function myFunc(x, y, ...params) {
  console.log(x); // -> "a"
  console.log(y); // -> "b"
  console.log(params); // -> ["c", "d", "e", "f"]
}
myFunc("a", "b", "c", "d", "e", "f");
```
```js
const { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
console.log(x); // -> 1
console.log(y); // -> 2
console.log(z); // -> { a: 3, b: 4 }
const n = { x, y, ...z };
console.log(n); // -> { x: 1, y: 2, a: 3, b: 4 }
```

#### Объяснение

##### В итерируемых объектах (наподобие массивов)
Если у нас есть два массива:
```js
const arr1 = ["a", "b", "c"];
const arr2 = [arr1, "d", "e", "f"]; // -> [["a", "b", "c"], "d", "e", "f"]
```
Первый элемент массива `arr2` — это массив, потому что `arr1` напрямую вставляется в `arr2`. Но мы хотим, чтобы `arr2` состоял только из букв. Чтобы добиться этого, мы можем *расширить* элементы массива `arr1` в массив `arr2`.

С использованием оператора расширения:
```js
const arr1 = ["a", "b", "c"];
const arr2 = [...arr1, "d", "e", "f"]; // -> ["a", "b", "c", "d", "e", "f"]
```

##### Оставшиеся аргументы функции
Мы можем использовать оператор оставшихся аругментов функции, чтобы вставить аргументы в массив, элементы которого можно перебрать при помощи цикла. К каждой функции уже привязан объект `arguments` — это массив, состоящий из всех аргументов, переданных функции.
```js
function myFunc() {
  for (var i = 0; i < arguments.length; i++) {
    console.log(arguments[i]);
  }
}
myFunc("Коля", "Андреев", 10, 12, 6);
// "Коля"
// "Андреев"
// 10
// 12
// 6
```
Но давайте представим, что мы хотим, чтобы наша функция создала нового студента, у которого будут отдельные оценки и средний балл. Удобнее будет записать первые два аргумента в две отдельные переменные, а все оценки поместить в массив, который можно перебирать.

Именно это позволяет нам сделать оператор оставшихся аргументов!
```js
function createStudent(firstName, lastName, ...grades) {
  /* firstName = "Коля"
  lastName = "Андреев"
  [10, 12, 6] — оператор `...` берет все остальные параметры, переданные функции,
  и создает переменную grades с массивом, в котором они хранятся. */
  const avgGrade = grades.reduce((acc, curr) => acc + curr, 0) / grades.length;
  // Высчитывает из всех оценок средний балл
  return {
    firstName: firstName,
    lastName: lastName,
    grades: grades,
    avgGrade: avgGrade,
  }
}
const student = createStudent("Коля", "Андреев", 10, 12, 6);
console.log(student);
/* {
firstName: "Коля",
lastName: "Андреев",
grades: [10, 12, 6],
avgGrade: 9,33
} */
```
> **Примечание:** `createStudent` — плохая функция, потому что мы не проверяем, существует ли `grades.length` и отличается ли от 0. Но так функцию легче прочитать, поэтому я этот случай не рассматриваю.

##### Расширение свойств объектов
Чтобы понять эту часть, рекомендую прочитать предыдущие объяснения о применении оператора оставшихся аргументов к функциям и итерируемым объектам.
```js
const myObj = { x: 1, y: 2, a: 3, b: 4 };
const { x, y, ...z } = myObj; // деструктуризация объекта
console.log(x); // -> 1
console.log(y); // -> 2
console.log(z); // -> { a: 3, b: 4 }
// z - это остаток деструктурированного объекта: myObj минус деструктурированные свойства х и у.
const n = { x, y, ...z };
console.log(n); // -> { x: 1, y: 2, a: 3, b: 4 }
// Здесь свойства объекта z расширяются в n
```

#### Дополнительные материалы
- [TC39 — Object Rest/Spread Properties for ECMAScript](https://github.com/tc39/proposal-object-rest-spread).
- [Spread Operator Introduction — WesBos](https://github.com/wesbos/es6-articles/blob/master/28%20-%20Spread%20Operator%20Introduction.md).
- [JavaScript & The spread operator](https://codeburst.io/javascript-the-spread-operator-a867a71668ca).
- [6 Great Uses of the Spread Operator](https://davidwalsh.name/spread-operator).

### Сокращенная запись свойств объектов
Когда вы записываете переменную в свойство объекта, если у переменной то же имя, что и у свойства, можно сделать следующее:
```js
const x = 10;
const myObj = { x };
console.log(myObj.x) // -> 10
```

#### Объяснение
Раньше (до ES2015), если вы хотели при объявлении нового *литерала объекта* использовать в качестве его свойств переменные, вам пришлось бы писать подобный код:
```js
const x = 10;
const y = 20;
const myObj = {
  x: x, // запись значения переменной х в myObj.x
  y: y, // запись значения переменной у в myObj.y
};
console.log(myObj.x); // -> 10
console.log(myObj.y); // -> 20
```
Как видите, приходится повторять одно и тоже, потому что имена свойств объекта совпадают с именами переменных, которые вы хотите записать в эти свойства.

С ES2015, если имя переменной совпадает с именем свойства, можно использовать такую сокращенную запись:
```js
const x = 10;
const y = 20;
const myObj = {
  x,
  y,
};
console.log(myObj.x); // -> 10
console.log(myObj.y); // -> 20
```

#### Дополнительные материалы
- [Enhanced Object Properties — ES6 Features](http://es6-features.org/#PropertyShorthand).

### Промисы
**Промис (promise)** — это объект, который может быть синхронно возвращён из асинхронной функции ([Ссылка](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261#3cd0)).

Промисы могут использоваться, чтобы избежать [глубоко вложенных колбэков](http://callbackhell.com/), и они всё чаще и чаще встречаются в современных JavaScript-проектах.

#### Пример кода
```js
const fetchingPosts = new Promise((res, rej) => {
  $.get("/posts")
  .done(posts => res(posts))
  .fail(err => rej(err));
});
fetchingPosts
  .then(posts => console.log(posts))
  .catch(err => console.log(err));
```

#### Пояснение
Когда вы делаете *AJAX-запрос*, ответ будет несинхронным, так как вы запрашиваете ресурс, на обработку которого требуется некоторое время. Вы также можете вообще не получить ответ, если он недоступен по какой-то причине (404).

Чтобы избежать таких ситуаций, в ES2015 были добавлены *промисы*. Промисы могут иметь 3 различных состояния:
- выполняется;
- выполнено;
- отклонено.

Предположим, мы хотим использовать промисы для обработки AJAX-запроса для извлечения ресурса X.

##### Создание промиса
Сначала нам нужно создать промис. Мы будем использовать GET-метод jQuery для создания AJAX-запроса к X.
```js
const xFetcherPromise = new Promise(
// Создаём промис с помощью ключевого слова new и сохраняем его в переменную
  function(resolve, reject) { /* Конструктор промиса принимает в виде параметра функцию,
    которая, в свою очередь, принимает 2 параметра: resolve и reject */
    $.get("X") // Запускаем AJAX-запрос
      .done(function(X) { // Как только запрос выполнен...
        resolve(X); // ... выполняем промис с X в качестве значения
      })
      .fail(function(error) { // Если запрос не прошёл...
        reject(error); // ... отклоняем промис со значением error
      });
  }
)
```
Как видно из рассмотренного примера, объект Promise принимает функцию, которая принимает два параметра: `resolve` и `reject`. Эти параметры — функции, которые при вызове изменяют состояние промиса со значения *выполняется* на *выполнено* или *отклонено*.

Промис находится в состоянии выполнения после создания экземпляра, и его функция-*исполнитель* выполняется немедленно. Как только одна из функций *выполнения* или *отклонения* вызвана в функции-*исполнителе*, промис вызовет связанные с ним обработчики.

##### Использование обработчиков промисов
Чтобы получить результат (или ошибку) промиса, мы должны присоединить к нему обработчики следующим образом:
```js
xFetcherPromise
  .then(function(X) {
    console.log(X);
  })
  .catch(function(err) {
    console.log(err);
  })
```
Если вызов прошёл успешно, вызывается `resolve`, и выполняется функция, переданная в метод `.then`.

Если вызов не прошёл, вызывается `reject` и выполняется функция, переданная в `.catch`.
> **Примечание:** Если обработчик присоединяется, когда промис уже был выполнен или отклонён, обработчик всё равно будет вызван. Так что нет никакого соревнования между выполнением асинхронной операции и вызовом ее обработчиков. [(Ссылка: MDN)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise)

#### Дополнительные материалы
- [JavaScript Promises for Dummies — Jecelyn Yeen](https://scotch.io/tutorials/javascript-promises-for-dummies).
- [JavaScript Promise API — David Walsh](https://davidwalsh.name/promises).
- [Using promises — MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises).
- [Master the JavaScript Interview: What is a Promise? — Eric Elliott](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261).
- [JavaScript Promises: an Introduction — Jake Archibald](https://developers.google.com/web/fundamentals/getting-started/primers/promises).
- [Документация по промисам — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise).

### Шаблонные строки
**Шаблонные строки** — это конструкция, позволяющая использовать [*интерполяцию выражений*](https://en.wikipedia.org/wiki/String_interpolation) в однострочных и многострочных строках.

Другими словами, это новый синтаксис записи строк, с которым удобно использовать любые выражения JavaScript (например, переменные).

#### Пример кода
```js
const name = "Коля";
`Привет, ${name}, следующее выражение равно четырем : ${2+2}`;
// -> Привет, Коля, следующее выражение равно четырем: 4
```

#### Дополнительные материалы
[String Interpolation — Особенности ES6](http://es6-features.org/#StringInterpolation).
[Getting Literal With ES6 Template Strings — Addy Osmani](https://developers.google.com/web/updates/2015/01/ES6-Template-Strings).

### Шаблонные строки с тегами
**Шаблонные теги** — это *функции, которые могут быть приставкой к [шаблонной строке](#template-literals)*. Когда функция вызывается таким образом, первый параметр представляет собой массив *строк*, которые появляются между интерполированными переменными, а последующие параметры являются интерполированными значениями. Используйте оператор расширения `...`, чтобы захватить их все. [(Ссылка: MDN)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals).
> **Примечание:** Известная библиотека, которая называется [стилизованные компоненты](https://www.styled-components.com/), основана на этой возможности.

Ниже приведен пример их работы.
```js
function highlight(strings, ...values) {
  const interpolation = strings.reduce((prev, next) => {
    return prev + next + (values.shift() || "");
  }, "");
  return `<mark>${interpolation}</mark>`;
}
const meal = "круассаны";
const drink = "кофе";
highlight`Я люблю ${meal} с ${meal}.`;
// "<mark>Я люблю круассаны с кофе.</mark>"
```
Более интересный пример:
```js
function comma(strings, ...values) {
  return strings.reduce((prev, next) => {
    let value = values.shift() || [];
    value = value.join(", ");
    return prev + next + value;
  }, "");
}
const snacks = ["яблоки", "бананы", "апельсины"];
comma`Я люблю ${snacks} на десерт.`;
// -> "Я люблю яблоки, бананы, апельсины на десерт."
```

#### Дополнительные материалы
- [Tagged Template Literals — Wes Bos](http://wesbos.com/tagged-template-literals/).
- [Библиотека common-tags](https://github.com/declandewet/common-tags).

### Импорт / экспорт
Модули в ES6 используются для получения доступа к переменным и функциям из других модулей, причем экспорт этих переменных и функций должен быть четко обозначен в исходном модуле.

Крайне рекомендую почитать ресурсы MDN об экспорте/импорте (см. Дополнительные материалы ниже), в них содержится четкая и полная информация.

#### Объяснение с примером кода
##### Именованный экспорт
Именованный экспорт используется для экспорта нескольких значений из модуля.
> **Примечание:** Вы можете именовать экспорт только [объектами первого класса](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0), у которых есть имя.

```js
// mathConstants.js
export const pi = 3.14;
export const exp = 2.7;
export const alpha = 0.35;
// -------------
// myFile.js
import { pi, exp } from './mathConstants.js';
// Именованный импорт — с синтаксисом, похожим на деструктуризацию.
console.log(pi) // -> 3.14
console.log(exp) // -> 2.7
// -------------
// mySecondFile.js
import * as constants from './mathConstants.js';
// Все экспортированные значения записываются в переменную constants.
console.log(constants.pi) // -> 3.14
console.log(constants.exp) // -> 2.7
```
Хотя именованный импорт выглядит как *деструктуризация*, это не одно и то же. Кроме того, именованный импорт имеет другой синтаксис, не поддерживает значения по умолчанию и *глубокую* деструктуризацию.

Вы также можете создавать псевдонимы, но их синтаксис будет отличаться от синтаксиса, используемого при деструктуризации:
```js
import { foo as bar } from 'myFile.js';
// foo импортируется и записывается в новую переменную bar
```

##### Импорт / экспорт по умолчанию
Экспорт по умолчанию может быть только один на каждый модуль. Это может быть функция, класс, объект или что-то еще. Это значение считается «главным», поскольку его будет проще всего импортировать [Ссылка: MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/export#Description).
```js
// coolNumber.js
const ultimateNumber = 42;
export default ultimateNumber;
// ------------
// myFile.js
import number from './coolNumber.js';
/* В переменную number автоматически попадает экспорт по умолчанию —
вне зависимости от его имени в исходном модуле. */
console.log(number) // -> 42
```
Экспорт функций:
```js
// sum.js
export default function sum(x, y) {
  return x + y;
}
// -------------
// myFile.js
import sum from './sum.js';
const result = sum(1, 2);
console.log(result) // -> 3
```

#### Дополнительные материалы
- [ES6 Modules in bulletpoints](https://ponyfoo.com/articles/es6#modules)
- [Экспорт — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/export).
- [Импорт — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import).
- [Understanding ES6 Modules](https://www.sitepoint.com/understanding-es6-modules/).
- [Destructuring special case — import statements](https://ponyfoo.com/articles/es6-destructuring-in-depth#special-case-import-statements)
- [Misunderstanding ES6 Modules — Kent C. Dodds](https://medium.com/@kentcdodds/misunderstanding-es6-modules-upgrading-babel-tears-and-a-solution-ad2d5ab93ce0)
- [Modules in JavaScript](http://exploringjs.com/es6/ch_modules.html#sec_modules-in-javascript)

### <a name="this_def"></a> `this` в JavaScript
Оператор `this` ведет себя не так, как в других языках. В большинстве случаев он определяется тем, как вызвана функция ([Ссылка: MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this)).

Это сложное понятие с множеством тонкостей, так что я крайне рекомендую вам тщательно изучить приведенные ниже Дополнительные материалы. Я покажу вам, как сам лично определяю, чему равно `this`. Этому меня научила [вот эта статья Yehuda Katz](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/).
```js
function myFunc() {
  ...
}
// После каждого выражения находим значение this в myFunc
myFunc.call("myString", "привет");
// myString — в this записывается значение первого параметра .call
// В non-strict-режиме
myFunc("привет");
// window — myFunc() — это синтаксический сахар для myFunc.call(window, "привет")
// В strict-режиме
myFunc("привет");
// undefined — myFunc() — это синтаксический сахар для myFunc.call(undefined, "привет")
```
```js
var person = {
  myFunc: function() { ... }
}
person.myFunc.call(person, "test");
// person Object — в this записывается значение первого параметра call
person.myFunc("test");
// person Object — person.myFunc() — это синтаксический сахар для person.myFunc.call(person, "test")
var myBoundFunc = person.myFunc.bind("привет");
// Создает новую функцию, в которой мы записываем "привет" в значение this
person.myFunc("test");
// person Object — Метод bind не влияет на первоначальный метод
myBoundFunc("test");
// "hello" — myBoundFunc — это person.myFunc, в которой this привязана к "привет"
```

#### Дополнительные материалы
- [Understanding JavaScript Function Invocation and "this" — Yehuda Katz](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/).
- [`this` в JavaScript — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this).

### Класс
JavaScript — это язык, [основанный на прототипах](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (в то время как, например, Java — язык,  [основанный на классах](https://en.wikipedia.org/wiki/Class-based_programming)). В обновлении ES6 представлены классы JavaScript, которые являются синтаксическим сахаром для наследования на основе прототипов, а **не** новой моделью наследования классов ([Ссылка](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)).

Если вы знакомы с классами в других языках, слово «класс» может ввести вас в заблуждение. Постарайтесь не делать предположений о работе классов в JavaScript на основе других языков. Считайте это совершенно другим понятием.

Поскольку этот документ не является попыткой научить вас языку с нуля, я надеюсь, что вы знаете, что такое прототипы и как они себя ведут. Но вот несколько ссылок, которые мне показались полезными для понимания этого понятия:
- [Understanding "Prototypes" in JavaScript — Yehuda Katz](http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/);
- [A Plain English Guide to JavaScript Prototypes — Sebastian Porto](http://sporto.github.io/blog/2013/02/22/a-plain-english-guide-to-javascript-prototypes/);
- [Наследование и цепочка прототипов — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

#### Примеры
До ES6, синтаксис на основе прототипов:
```js
var Person = function(name, age) {
  this.name = name;
  this.age = age;
};
Person.prototype.stringSentence = function() {
  return "Привет, меня зовут " + this.name + " и мне " + this.age;
};
```
Начиная с ES6, синтаксис на основе классов:
```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  stringSentence() {
    return `Привет, меня зовут ${this.name} и мне ${this.age}`;
  }
}

const myPerson = new Person("Маша", 23);
console.log(myPerson.age); // -> 23
console.log(myPerson.stringSentence()); // -> "Привет, меня зовут Маша и мне 23
```

#### Дополнительные материалы
Для понимания прототипов:
- [Understanding Prototypes in JS - Yehuda Katz](http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/)
- [A plain English guide to JS prototypes - Sebastian Porto](http://sporto.github.io/blog/2013/02/22/a-plain-english-guide-to-javascript-prototypes/)
- [Наследование и цепочка прототипов — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

Для понимания классов:
- [ES6 Classes in Depth - Nicolas Bevacqua](https://ponyfoo.com/articles/es6-classes-in-depth)
- [ES6 Features - Classes](http://es6-features.org/#ClassDefinition)
- [Классы JavaScript — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes).

### Async Await
Помимо [Промисов](#promises) вам может встретиться еще один синтаксис для обработки асинхронного кода — `async`/`await`.

Цель функций `async`/`await` — упрощение поведения при синхронном использовании промисов и выполнение какой-либо обработки группы промисов. Промисы похожи на структурированные обратные вызовы, а `async`/`await` точно так же похожи на комбинацию генераторов и промисов. ([Ссылка: MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/async_function))
> **Примечание:** перед тем, как пытаться понять `async`/`await`, вы должны понимать, что такое промисы и как они работают, поскольку `async`/`await` основаны на промисах.

> **Примечание 2:** [`await` должен использоваться в `async` функции](https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9#f3f0), что означает, что вы не можете использовать `await` в верхнем уровне вашего кода, так как он не находится внутри async-функции.

#### Пример кода
```js
async function getGithubUser(username) {
// ключевое слово async позволяет использование await в функции и означает, что функция возвращает промис
  const response = await fetch(`https://api.github.com/users/${username}`);
  // «синхронное» ожидание промиса перед переходом на новую строку
  return response.json();
}

getGithubUser('mbeaudru')
  .then(user => console.log(user)) // логирование пользователя — не может использовать синтаксис await, так как этот код не находится внутри async-функции.
  .catch(err => console.log(err)); // если в нашей асинхронной функции возникнет ошибка, то мы поймаем ее здесь
```

#### Объяснение с помощью примера кода
`async`/`await` построены на промисах, но они позволяют использовать более императивный стиль кода.

Оператор `async` превращает функцию в *промис*, в котором можно использовать оператор `await`.
```js
async function myFunc() {
// можно использовать оператор await, так как это async-функция
  return "hello world";
}
myFunc().then(msg => console.log(msg))
// "Привет, мир!" — myFunc превращается в промис из-за оператора async
```
Когда достигается оператор `return` async-функции, промис выполняется с возвращаемым значением. Если внутри async-функции выпадает ошибка, состояние промиса изменится на `rejected`.

Оператор `await` используется для ожидания выполнения *промиса* и может быть использован только в теле async-функции. При этом выполнение кода приостанавливается, пока не будет выполнен промис.
> **Примечание:** `fetch` — это промис, который позволяет выполнить AJAX-запрос.

Давайте сначала посмотрим, как мы можем получить пользователя github с помощью промисов:
```js
function getGithubUser(username) {
  return fetch(`https://api.github.com/users/${username}`).then(response => response.json());
}

getGithubUser('mbeaudru')
  .then(user => console.log(user))
  .catch(err => console.log(err));
```
Вот эквивалент с использованием  `async`/`await`:
```js
async function getGithubUser(username) {
// превращение в промис + разрешено использование ключевого слова await
  const response = await fetch(`https://api.github.com/users/${username}`);
  // Выполнение останавливается здесь, пока не закончится выполнение промиса.
  return response.json();
}
getGithubUser('mbeaudru')
  .then(user => console.log(user))
  .catch(err => console.log(err));
```
Синтаксис `async`/`await` особенно удобен, когда вам нужно связывать взаимозависимые промисы.

Например, вам нужно получить токен для того, чтобы получить публикацию в блоге из базы данных, а затем информацию об авторе.
> **Примечание:** Выражение `await` должно быть заключено в круглые скобки для вызова методов и свойств разрешенных значений в одной строке.

```js
async function fetchPostById(postId) {
  const token = (await fetch('token_url')).json().token;
  const post = (await fetch(`/posts/${postId}?token=${token}`)).json();
  const author = (await fetch(`/users/${post.authorId}`)).json();

  post.author = author;
  return post;
}

fetchPostById('gzIrzeo64')
  .then(post => console.log(post))
  .catch(err => console.log(err));
```

##### Обработка ошибок
Если мы не добавим блок `try` / `catch` вокруг выражения `await`, непойманные исключения — неважно, были ли они выброшены в теле вашей async-функции, или во время ожидания выполнения `await` — отклонят промис, возвращенный из async-функции. Использование состояния `throw` в асинхронной функции — то же самое, что возврат промиса, который был отклонен. [(Ссылка: PonyFoo)](https://ponyfoo.com/articles/understanding-javascript-async-await#error-handling).
> **Примечание:** Промисы ведут себя так же!

С помощью промисов вот как бы мы справились с цепочкой ошибок:
```js
function getUser() { // Этот промис будет отклонен!
  return new Promise((res, rej) => rej("Пользователь не найден!"));
}

function getAvatarByUsername(userId) {
  return getUser(userId).then(user => user.avatar);
}

function getUserAvatar(username) {
  return getAvatarByUsername(username).then(avatar => ({ username, avatar }));
}

getUserAvatar('mbeaudru')
  .then(res => console.log(res))
  .catch(err => console.log(err)); // -> "Пользователь не найден!"
```
Эквивалент с использованием `async`/`await`:
```js
async function getUser() {
  // Возвращенный промис будет отклонен!
  throw "User not found !";
}

async function getAvatarByUsername(userId) => {
  const user = await getUser(userId);
  return user.avatar;
}

async function getUserAvatar(username) {
  var avatar = await getAvatarByUsername(username);
  return { username, avatar };
}

getUserAvatar('mbeaudru')
  .then(res => console.log(res))
  .catch(err => console.log(err)); // -> "Пользователь не найден!"
```

#### Дополнительные материалы
- [Async/Await — JavaScript.Info](https://javascript.info/async-await).
- [ES7 Async/Await](http://rossboucher.com/await/#/).
- [6 Reasons Why JavaScript’s Async/Await Blows Promises Away](https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9).
- [JavaScript awaits](https://dev.to/kayis/javascript-awaits).
- [Using Async Await in Express with Node 8](https://medium.com/@Abazhenov/using-async-await-in-express-with-node-8-b8af872c0016).
- [Функция Async](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/async_function).
- [Await](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/await).
- [Using async / await in express with node 8](https://medium.com/@Abazhenov/using-async-await-in-express-with-node-8-b8af872c0016).

### Правдиво / Ложно
В JavaScript «истинность» или «ложность» значения определяется при вычислении этого значения в булевом контексте. Примером булева контекста может быть вычисление в условии `if`.

Любое значение будет приведено к `true` (истина), кроме:
- `false` (ложь);
- `0`;
- `""` (пустая строка);
- `null`;
- `undefined`;
- `NaN`.

Вот примеры *булева контекста*:
- значение условия `if`.
```js
if (myVar) {}
```

Значение `myVar` может быть любым [объектом первого класса](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0) (переменная, функция, логическое значение), но оно будет переведено в логическое значение, поскольку оно вычисляется в булевом контексте.

- После логического оператора **NOT** `!`.

Этот оператор возвращает значение «ложь», если его единственный операнд может быть преобразован к значению «истина»; иначе он возвращает значение «истина».
```js
!0 // -> «истина»: 0 — это «ложь», поэтому вернется «истина».
!!0 // -> «ложь»: 0 — это «ложь», следовательно !0 возвращает истину, а !(!0) возвращает «ложь».
!!"" // -> «ложь»: пустая строка — «ложь», поэтому НЕ (НЕ «ложь») равно «ложь».
```
- Конструктор объектов типа `Boolean`.

```js
new Boolean(0); // «ложь»
new Boolean(1); // «истина»
```
- Тернарный оператор.

```js
myVar ? "истина" : "ложь"
```

Значение `myVar` вычисляется в булевом контексте.

### Статические методы

#### Краткое объяснение
Ключевое слово `static` используется в классах для объявления статических методов. Статические методы — это функции в классе, которые принадлежат к объектам класса, и недоступны никаким экземплярам этого класса.

#### Пример кода
```js
class Repo {
  static getName() {
    return "Repo name is modern-js-cheatsheet";
  }
}
// Обратите внимание, что нам не пришлось создавать экземпляр класса Repo
console.log(Repo.getName()); // Repo name is modern-js-cheatsheet
let r = new Repo();
console.log(r.getName()); // Не пойманный TypeError: repo.getName не является функцией
```

#### Подробное объяснение
Статические методы можно вызвать в другом статическом методе, используя ключевое слово `this`, однако это не работает для нестатических методов. Нестатические методы не могут напрямую обращаться к статическим методам, используя ключевое слово `this`.

##### Вызов статических методов из статического метода.
Для вызова статического метода из другого статического метода можно использовать ключевое слово `this` следующим образом:
```js
class Repo {
  static getName() {
    return "Repo name is modern-js-cheatsheet";
  }
  static modifyName(){
    return `${this.getName()}-added-this`;
  }
}
console.log(Repo.modifyName()); // Repo name is modern-js-cheatsheet-added-this
```

##### Вызов статических методов из нестатических методов
Нестатические методы могут вызывать статические двумя способами:

1. Используя имя класса.

Чтобы получить доступ к статическому методу из нестатического, используем имя класса и вызываем статический метод как обычное свойство, например, `ClassName.StaticMethodName`:
```js
class Repo {
  static getName() {
    return "Repo name is modern-js-cheatsheet"
  }
  useName(){
    return `${Repo.getName()} and it contains some really important stuff`;
  }
}
// нужно создать экземпляр класса для использования нестатических методов
let r = new Repo();
console.log(r.useName()); //Repo name is modern-js-cheatsheet and it contains some really important stuff
```

2. Используя конструктор.

Статические методы можно вызвать как свойства объекта-конструктора класса.
```js
class Repo {
  static getName() {
    return "Repo name is modern-js-cheatsheet"
  }
useName(){
//Вызывает статический метод как обычное свойство конструктора
  return `${this.constructor.getName()} and it contains some really important stuff`;
  }
}
// нужно создать экземпляр класса для использования нестатических функций
let r = new Repo();
console.log(r.useName()); // Repo name is modern-js-cheatsheet and it contains some really important stuff
```

#### Дополнительные материалы
- [Ключевое слово static — MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/static).
- [Static Methods- Javascript.info](https://javascript.info/class#static-methods)
- [Static Members in ES6- OdeToCode](http://odetocode.com/blogs/scott/archive/2015/02/02/static-members-in-es6.aspx)

## Глоссарий

### <a name="scope_def"></a> Область видимости
Контекст, в котором переменная и выражения являются «видимыми» или могут быть получены. Если переменная или выражение находятся «вне текущей области видимости», значит, их нельзя использовать.

Источник: [MDN](https://developer.mozilla.org/ru/docs/Glossary/Scope)

### <a name="mutation_def"></a> Изменение переменных
Говорят, что переменная изменилась, когда её значение изменилось относительно начального.
```js
var myArray = [];
myArray.push("firstEl") // значение myArray изменено
```
Переменная называется *неизменяемой*, если она не может быть изменена.

Более подробно [смотрите в статье на MDN](https://developer.mozilla.org/ru/docs/Glossary/Mutable).
